grammar<'input>;

use parser::types;
use tok::{Tok, Error, CaseInsensitiveUserStr, UserStr};

pub Program: types::Program =
    <programs_units: Stmts<ProgramUnit>> =>
        types::Program::new(programs_units);

ProgramUnit: types::ProgramUnit = {
    MainProgram,
    // ExternalSubprogram,
    // Module,
    // Submodule,
    // BlockData,
};

MainProgram: types::ProgramUnit = {
    // <stmt:ProgramStmt?> SpecificationPart? ExecutionPart? InternalSubprogramPart? <end:EndProgramStmt> =>
    //     types::ProgramUnit::new(stmt, end),
    <stmt:ProgramStmt?> SpecificationPart ExecutionPart? <end:EndProgramStmt> =>
        types::ProgramUnit::new(stmt, end),
};

ProgramStmt: String = {
    "PROGRAM" <name:"Id"> ";" => name.as_string()
};

EndProgramStmt: Option<String> = {
    <program: EndProgram> ";" => program
};

EndProgram: Option<String> = {
    "END" "PROGRAM" <name:"Id"> => Some(name.as_string()),
    "END" "PROGRAM"?            => None,
};

// R204
SpecificationPart: () = {
    // UseStmt* ImportStmt* ImplicitPart? DeclarationConstruct*,
    DeclarationConstruct*,
};

// R205
// ImplicitPart: () = {};

// R207
DeclarationConstruct: () = {
    SpecificationConstruct,
    // DataStmt,
    // FormatStmt,
    // EntryStmt,
    // StmtFunctionStmt,
};

// R208
SpecificationConstruct: () = {
    // DerivedTypeDef,
    // EnumDef,
    // GenericStmt,
    // InterfaceBlock,
    // ParameterStmt,
    // ProcedureDeclarationStmt,
    // OtherSpecificationStmt,
    TypeDeclarationStmt,
};

// R209
ExecutionPart: () = {
    // ExecutableConstruct ExecutionPartConstruct*,
    ExecutableConstruct
};

// R210
// ExecutionPartConstruct: () = {
//     ExecutableConstruct,
//     // FormatStmt,
//     // EntryStmt,
//     // DataStmt,
// };

// R211
// InternalSubprogramPart: () = {};

// R214
ExecutableConstruct: () = {
    ActionStmt,
    // AssociateConstruct,
    // BlockConstruct,
    // CaseConstruct,
    // CriticalConstruct,
    // DoConstruct,
    // IfConstruct,
    // SelectRankConstruct,
    // SelectTypeConstruct,
    // WhereConstruct,
    // ForallConstruct,
};

// R215
ActionStmt: () = {
    // AllocateStmt,
    // AssignmentStmt,
    // BackspaceStmt,
    // CallStmt,
    // CloseStmt,
    // ContinueStmt,
    // CycleStmt,
    // DeallocateStmt,
    // EndFunctionStmt,
    // EndMpSubprogramStmt,
    // EndProgramStmt,
    // EndSubroutineStmt,
    // EndfileStmt,
    // ErrorStopStmt,
    // EventPostStmt,
    // EventWaitStmt,
    // ExitStmt,
    // FlushStmt,
    // GotoStmt,
    // IfStmt,
    // InquireStmt,
    // LockStmt,
    // NullifyStmt,
    // OpenStmt,
    // PointerAssignmentStmt,
    PrintStmt,
    // ReadStmt,
    // ReturnStmt,
    // RewindStmt,
    // StopStmt,
    // SyncAllStmt,
    // SyncImagesStmt,
    // SyncMemoryStmt,
    // UnlockStmt,
    // WaitStmt,
    // WhereStmt,
    // WriteStmt,
    // ComputedGotoStmt,
    // ForallStmt,
};

// R216
Keyword = "Id";

// R403
DeclarationTypeSpec: () = {
    IntrinsicTypeSpec,
    // "TYPE" "(" IntrinsicTypeSpec ")",
    // "TYPE" "(" DerivedTypeSpec ")",
    // "CLASS" "(" DerivedTypeSpec ")",
    // "CLASS" "(" "*" ")",
    // "TYPE" "(" "*" ")",
};

// R404
IntrinsicTypeSpec: () = {
    IntegerTypeSpec,
    "REAL" KindSelector?,
    "DOUBLE" "PRECISION",
    "COMPLEX" KindSelector?,
    // "CHARACTER" CharSelector?,
    "LOGICAL" KindSelector?,
};

// R405
IntegerTypeSpec: () = "INTEGER" KindSelector?;

// R406
KindSelector: () = ("KIND" "=")? IntConstantExpr;

// R421
// CharSelector: () = {
    // LengthSelector,
    // "(" "LEN" "=" TypeParamValue "," "KIND" "=" IntConstantExpr ")",
    // "(" TypeParamValue "," ("KIND" "=")? IntConstantExpr ")",
    // "(" "KIND" "=" IntConstantExpr ("," "LEN" "=" TypeParamValue)? ")",
// };

// R422
// LengthSelector: () = {
    // "(" ("LEN" "=")? TypeParamValue ")",
    // "*" CharLength ","?
// };

// R423
// CharLength: () = {
    // "(" TypeParamValue ")",
    // IntLiteralConstant,
// };

// R444
InitialDataTarget: () = Designator;

// R501
TypeDeclarationStmt: () = {
    DeclarationTypeSpec (("," AttrSpec)* "::") List<EntityDecl> ";"
};

// R502
AttrSpec: () = {
    AccessSpec,
    "ALLOCATABLE",
    "ASYNCHRONOUS",
    // "CODIMENSION" "[" CoarraySpec "]",
    "CONTIGUOUS",
    // "DIMENSION" "(" ArraySpec ")",
    "EXTERNAL",
    "INTENT" "(" IntentSpec ")",
    "INTRINSIC",
    LanguageBindingSpec,
    "OPTIONAL",
    "PARAMETER",
    "POINTER",
    "PROTECTED",
    "SAVE",
    "TARGET",
    "VALUE",
    "VOLATILE",
};

// R503
EntityDecl: () = {
    // ObjectName ("(" ArraySpec ")")? ("[" CoarraySpec "]")? ("*" CharLength)? Initialization?,
    ObjectName Initialization?,
};

// R504
ObjectName: () = "Id";

// R505
Initialization: () = {
    "=" ConstantExpr,
    "=>" NullInit,
    "=>" InitialDataTarget,
};

// R506
NullInit: () = "Id" "(" ")";

// R507
AccessSpec: () = {
    "PUBLIC",
    "PRIVATE",
};

// R508
LanguageBindingSpec: () = {
    "BIND" "(" "C" ("," "NAME" "=" DefaultCharConstantExpr)? ")"
};

// R509
// CoarraySpec: () = {
    // List<DeferredCoshapeSpec>,
    // ExplicitCoshapeSpec,
// };

// R515
// ArraySpec: () = {
    // List<ExplicitShapeSpec>,
    // List<AssumedShapeSpec>,
    // List<DeferredShapeSpec>,
    // AssumedSizeSpec,
    // ImpliedShapeSpec,
    // ImpliedShapeOrAssumedSizeSpec,
    // AssumedRankSpec,
// };

// R526
IntentSpec: () = {
    "IN",
    "OUT",
    "INOUT"
};

// R601
Designator: () = {
    ObjectName,
    // ArrayElement,
    // ArraySection,
    // CoindexedNamedObject,
    // ComplexPartDesignator,
    // StructureComponent,
    // Substring,
};

// R602
// "Variable" is ambiguous with a Primary, so Variable will need to be
// dis-ambiguated after parsing.
// Variable = DesignatorOrFunctionReference;

// R610
SubstringRange: () = {
    ":" IntExpr?,
    IntExpr ":" IntExpr?,
};

// R611
DataRef = PartRef ("%" PartRef)*;

// R612
PartRef = PartName ("(" SubstringRangeOrArgListOrSectionSubscript ")")?;
//PartRef = PartName ("(" SubstringRangeOrArgListOrSectionSubscript ")")? ImageSelector?;

SubstringRangeOrArgListOrSectionSubscript: () = {
    SubscriptOrVectorSubscript,
    Expr? ":" Expr?,
    Subscript? ":" Subscript? (":" Stride)?,
    List<ActualArgSpec>,
};

// part-name
PartName = "Id";

// R617
// ArrayElement = DataRef;

// R619
Subscript = IntExpr;

// R620
// uses of 'section-subscript' cannot be disambiguated from
// SubstringRangeOrArgOrSectionSubscript
// SectionSubscript: () = {
//     Subscript,
//     SubscriptTriplet,
//     VectorSubscript,
// };

// R621
SubscriptTriplet = Subscript? ":" Subscript? (":"  Stride)?;

// R622
// stride IS scalar-int-expr
Stride = IntExpr;

// R623
VectorSubscript = IntExpr;

// R619 + R623
SubscriptOrVectorSubscript = IntExpr;

// R701
Primary: () = {
    Constant,
    DesignatorOrFunctionReference,
    // ArrayConstructor,
    // StructureConstructor,
    // TypeParamInquiry,
    // TypeParamName,
    "(" Expr ")"
};

// R725
DefaultCharExpr: () = Expr;

// R726
IntExpr: () = Expr;

// R729
ConstantExpr: () = Expr;

// R730
DefaultCharConstantExpr: () = DefaultCharExpr;

// R731
IntConstantExpr: () = IntExpr;

// R1109
// UseStmt: () = {
//     "USE" (("," ModuleNature)? "::")? ModuleName ("," List<Rename>)?,
//     "USE" (("," ModuleNature)? "::")? ModuleName "," "ONLY" ":" List<Only>,
// };

// ModuleName = "Id";

// // R1110
// ModuleNature: () = {
//     "INTRINSIC",
//     "NON_INTRINSIC",
// };

// // R1111
// Rename: () = {
//     LocalName "=>" UseName,
//     "OPERATOR" LocalDefinedOperator "=>" "OPERATOR" UseDefinedOperator,
// };

// LocalName = "Id";
// UseName = "Id";

// // R1112
// Only: () = {
//     GenericSpec,
//     OnlyUseName,
//     Rename,
// };

// OnlyUseName = "Id";

// R1114
// LocalDefinedOperator: () = "DefinedOp";

// // R1115
// UseDefinedOperator: () = "DefinedOp";

// R1211
// ImportStmt: () = {};

// R1221
// 'function-reference' is ambiguous with a designator (e.g. an array element
// looks the same as a function call)
DesignatorOrFunctionReference: () = {
    DataRef,
    "CharLiteral" "(" SubstringRange ")",
};

// FunctionReference: () = ProcedureDesignator "(" List<ActualArgSpec> ")";

// R1223
// ProcedureDesignator: () = {
//     ProcedureName,
//     // ProcComponentRef,
//     DataRef "%" BindingName,
// };

BindingName: () = "Id";
ProcedureName: () = "Id";

// R1224
ActualArgSpec = (Keyword "=")? ActualArg;

// R1225
ActualArg: () = {
    Expr,
    // Variable,
    // ProcedureName,
    // ProcComponentRef,
    // AltReturnSpec,
};

PrintStmt: () = "PRINT" Format "," List<OutputItem> ";";

Format: () = {
    DefaultCharExpr,
    Label,
    "*"
};

Label = "DigitString";

OutputItem: () = {
    Expr,
    // IoImpliedDo
};

Expr: () = {
    Level5Expr,
    Expr "DefinedOp" Level5Expr,
};

Level5Expr: () = {
    EquivOperand,
    Level5Expr EquivOp EquivOperand
};

Level4Expr: () = {
    Level3Expr,
    Level3Expr RelOp Level3Expr,
};

Level3Expr: () = {
    Level2Expr,
    Level3Expr "//" Level2Expr,
};

Level2Expr: () = {
    AddOperand,
    AddOp AddOperand,
    Level2Expr AddOp AddOperand,
};
Level1Expr: () = {
    Primary,
    "DefinedOp" Primary,
};

AndOperand: () = {
    Level4Expr,
    ".NOT." Level4Expr,
};

OrOperand: () = {
    AndOperand,
    OrOperand ".AND." AndOperand,
};

EquivOperand: () = {
    OrOperand,
    EquivOperand ".OR." OrOperand,
};

MultOperand: () = {
    Level1Expr,
    Level1Expr "**" MultOperand,
};

AddOperand: () = {
    MultOperand,
    AddOperand MultOp MultOperand,
};

EquivOp: () = {
    ".EQV.",
    ".NEQV.",
};

RelOp: () = {
    ".EQ.",
    ".NE.",
    ".LT.",
    ".LE.",
    ".GT.",
    ".GE.",
};

AddOp: () = {
    "+",
    "-",
};

MultOp: () = {
    "*",
    "/"
};

Constant: () = {
    LiteralConstant,
    // NamedConstant,
};

LiteralConstant: () = {
    // IntLiteralConstant,
    // RealLiteralConstant,
    // ComplexLiteralConstant,
    // LogicalLiteralConstant,
    "CharLiteral",
    // BozLiteralConstant,
};

Stmts<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

List<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

extern {
    type Location = usize;
    type Error = Error;

    enum Tok<'input> {
        "PROGRAM"        => Tok::Program,
        "END"            => Tok::End,
        "PRINT"          => Tok::Print,
        "Id"             => Tok::Id(<CaseInsensitiveUserStr<'input>>),
        "IntegerLiteral" => Tok::IntegerLiteralConstant(<UserStr<'input>>),
        "DigitString"    => Tok::DigitString(<UserStr<'input>>),
        "CharLiteral"    => Tok::CharLiteralConstant(<UserStr<'input>>),
        "DefinedOp"      => Tok::DefinedOperator(<CaseInsensitiveUserStr<'input>>),
        ".AND."          => Tok::And,
        ".EQV."          => Tok::Equivalent,
        ".NEQV."         => Tok::NotEquivalent,
        ".NOT."          => Tok::Not,
        ".OR."           => Tok::Or,
        ".EQ."           => Tok::EqualsOp,
        ".NE."           => Tok::NotEqualsOp,
        ".LT."           => Tok::LessThan,
        ".LE."           => Tok::LessThanOrEquals,
        ".GT."           => Tok::GreaterThan,
        ".GE."           => Tok::GreaterThanOrEquals,
        "//"             => Tok::SlashSlash,
        "=>"             => Tok::Arrow,
        "="              => Tok::Equals,
        "+"              => Tok::Plus,
        "-"              => Tok::Minus,
        "*"              => Tok::Star,
        "/"              => Tok::Slash,
        "%"              => Tok::Percent,
        "**"             => Tok::StarStar,
        ";"              => Tok::EOS,
        ":"              => Tok::Colon,
        "::"             => Tok::ColonColon,
        ","              => Tok::Comma,
        "("              => Tok::LeftParen,
        ")"              => Tok::RightParen,
        "["              => Tok::LeftBracket,
        "]"              => Tok::RightBracket,

        // Types
        "REAL"           => Tok::Real,
        "DOUBLE"         => Tok::Double,
        "PRECISION"      => Tok::Precision,
        "COMPLEX"        => Tok::Complex,
        "CHARACTER"      => Tok::Character,
        "LOGICAL"        => Tok::Logical,
        "INTEGER"        => Tok::Integer,
        "KIND"           => Tok::Kind,

        // Attributes
        "ALLOCATABLE"    => Tok::Allocatable,
        "ASYNCHRONOUS"   => Tok::Asynchronous,
        "CODIMENSION"    => Tok::Codimension,
        "CONTIGUOUS"     => Tok::Contiguous,
        "DIMENSION"      => Tok::Dimension,
        "EXTERNAL"       => Tok::External,
        "INTENT"         => Tok::Intent,
        "INTRINSIC"      => Tok::Intrinsic,
        "OPTIONAL"       => Tok::Optional,
        "PARAMETER"      => Tok::Parameter,
        "POINTER"        => Tok::Pointer,
        "PROTECTED"      => Tok::Protected,
        "SAVE"           => Tok::Save,
        "TARGET"         => Tok::Target,
        "VALUE"          => Tok::Value,
        "VOLATILE"       => Tok::Volatile,

        // Access
        "PUBLIC"         => Tok::Public,
        "PRIVATE"        => Tok::Private,

        // Language Spec
        "BIND"           => Tok::Bind,
        "C"              => Tok::C,
        "NAME"           => Tok::Name,

        // Intent
        "IN"             => Tok::In,
        "OUT"            => Tok::Out,
        "INOUT"          => Tok::Inout,

        "USE"            => Tok::Use,
        "NON_INTRINSIC"  => Tok::NonIntrinsic,
        "ONLY"           => Tok::Only,
        "OPERATOR"       => Tok::Operator,
    }
}